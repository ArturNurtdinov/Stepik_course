# Stepik_course_c++
https://stepik.org/course/7/syllabus


Напишите функцию power, реализующую возведение целого числа в неотрицательную целую степень. Функция power должна принимать на вход два целых числа и возвращать целое число (смотрите шаблон кода). При выполнении задания учтите, что функция обязательно должна называться power, функция ничего не должна читать со входа или выводить.
Требования к реализации: в этом задании вам нужно реализовать только функцию power. Вы можете определять вспомогательные функции, если они вам нужны. Реализовывать функции main не нужно. 
Ограничения: библиотеку cmath (и math.h) использовать запрещено.
```c++
int power(int x, unsigned p) {
  int answer = 1;
  for (int i = 0; i < p; ++i) {
    answer *= x;
  }
  return answer;
}
```

---

Из лекции вы узнали, что использование макросов вместо функций — это зло. Для того, чтобы лучше разобраться, почему так непросто написать хороший макрос, и почему макросы лучше не использовать, мы предлагаем вам самостоятельно реализовать такую функцию-макрос.
Реализуйте макрос MAX от трёх параметров, который присваивает целочисленной (int) переменной, переданной в качестве третьего аргумента, наибольшее из значений, переданных в первых двух аргументах. Пример вызова макроса:
```c++
int a = 10;
int b = 20;
int c = 0;
MAX(a, b, c); // теперь c равно 20
MAX(a += b, b, c); // теперь a = с = 30
```
При написании макроса постарайтесь учесть как можно больше вариантов его использования. 

Требования к реализации: вам нужно реализовать только макрос MAX. Функцию main и какие-либо другие функции реализовывать не нужно. Попробуйте решить эту задачу исключительно средствами макросов.

Подсказка: возможно вам потребуется какая-нибудь синтаксическая конструкция для объединения нескольких инструкций.  Помните, что макросы просто подставляют текст в место вызова, препроцессор ничего не знает про синтаксис C++. Напишите макрос так, чтобы при его подстановке в месте вызова получился корректный код. Проверьте, что Ваш код можно применить несколько раз в одной функции и это не вызовет ошибку. Если будете определять какие-нибудь переменные, то постарайтесь сделать так, чтобы они не влияли на внешний код.

```c++
#define MAX(x, y, r) \
do { int aa = ( x ); int bb = ( y ); ( r ) = bb < aa ? aa : bb; } while ( false )
```

---

Простая задача на закрепления материала по работе с  вводом/выводом. Напишите программу, которая суммирует целые числа. На вход программе подаются целые числа в следующем формате: на первой строке идет целое число T — количество тестов, далее следует T строк, в каждой из которых через пробел идут два целых числа ai и bi. На выводе для каждой из T строк нужно вывести сумму ai+bi  в том порядке, в котором пары поступают на вход. Ничего, кроме этого, выводить не нужно.
```c++
#include <iostream>
using namespace std;

int main()
{
  int T;
  cin >> T;
  int a, b;
  for (int i = 0; i < T; ++i)
  {
    cin >> a;
    cin >> b;
    cout << a + b << '\n';
  }
  return 0;
}
```

---

Напишите программу для решения квадратных уравнений вида ax2+bx+c=0 (относительно x). На вход программа получает три целых числа: a , b и c, соответственно. При этом гарантируется, что a≠0. На вывод программа должна вывести два вещественных корня уравнения, разделённые пробелом. Если вещественных корней нет, то программа должна вывести строку "No real roots". Если у уравнения имеется только один корень (кратный корень), то программа должна вывести его дважды. Порядок вывода корней не важен. Ничего, кроме этого, выводить не нужно. Для вычислений с плавающей точкой используйте тип double. При выполнении задания вам может оказаться полезной функция sqrt из заголовочного файла cmath.

Замечание: после того, как вы сдадите это задание, попробуйте подумать, как изменилась бы ваша программа, если бы мы не гарантировали, что a≠0.
```c++
#include <iostream>
#include <cmath>

int main()
{
  int a, b, c;

  std::cin >> a >> b >> c;
  int discriminant = b * b - 4 * a * c;
  if (discriminant >= 0)
  {
    double r1 = (-b + sqrt(discriminant)) / (2 * a);
    double r2 = (-b - sqrt(discriminant)) / (2 * a);
    std::cout << r1 << " " << r2;
  }
  else
  {
    std::cout << "No real roots";
  }

  return 0;
}
```

---

Напишите программу, которая посимвольно читает из std::cin, пока не достигнет конца потока ввода, и заменяет несколько подряд идущих пробелов одним и выводит полученный результат в std::cout. Никаких других символов, кроме пробелов удалять не нужно. При выполнении задания вам не разрешается пользоваться дополнительной памятью, а именно: массивами, стандартными контейнерами и строками, даже если вы уже с ними знакомы. Вы можете определять любые вспомогательные функции, если они вам нужны.

Подсказка: прочтите внимательно степ про посимвольный ввод. Нулевой символ ('\0'), символ новой строки ('\n') и конец потока — это три разные вещи. Про то, как отловить конец потока —  написано в степе про посимвольный ввод.
```c++
#include <iostream>

using namespace std;

int main()
{
  char c = '\0';
  while (cin.get(c))
  {
    while (c == ' ' && cin.peek() == ' ')
    {
      cin.get(c);
    }
    cout << c;
  }
  return 0;
};
```

---

Напишите программу для вычисления целочисленного логарифма по основанию 2. На вход программе в первой строке подается число T, далее следует T строк с тестами. Каждый тест состоит из одного целого положительного числа ai<109, для каждого ai нужно вывести на отдельной строке такое наибольшее число p, что 2p≤ai. Гарантируется, что ai≥1 . При решении задачи вы можете определять любые вспомогательные функции, если они вам нужны, более того рекомендуется вынести вычисление логарифма в отдельную функцию.

Ограничения: библиотеку cmath (и math.h) использовать запрещено.
```c++
#include <iostream>

int log(int);

int main()
{
  int n;
  std::cin >> n;
  while (n--)
  {
    int k;
    std::cin >> k;

    std::cout << log(k) << std::endl;
  }
  return 0;
}

int log(int k)
{
  int p = -1;
  do
  {
    k >>= 1;
    ++p;
  } while (k);

  return p;
}
```

---

Напишите рекурсивную функцию вычисления наибольшего общего делителя двух положительных целых чисел (Greatest Common Divisor, GCD). Для этого воспользуйтесь следующими свойствами:

1. GCD(a,b)=GCD(b,amodb) 
2. GCD(0,a)=a 
3. GCD(a,b)=GCD(b,a) 
Требования к реализации: в данном задании запрещено пользоваться циклами. Вы можете заводить любые вспомогательные функции, если они вам нужны. Функцию main определять не нужно.
```c++
unsigned gcd(unsigned a, unsigned b)
{
  return !b ? a : gcd(b, a % b);
}
```

---

Вам требуется написать программу, которая "переворачивает" последовательность положительных целых чисел. На вход подается последовательность разделенных пробелами положительных целых чисел. Последовательность заканчивается нулем. Требуется вывести эту последовательность в обратном порядке.

На выводе числа нужно так же разделить пробелами. Завершающий ноль — это просто индикатор конца последовательности, он не является ее частью, т.е. выводить его не нужно.

Требования к реализации: в данном задании запрещено использовать циклы, а также дополнительную память: массивы, строки или контейнеры (даже, если вы с ними уже знакомы). Вам разрешено заводить вспомогательные функции, если они вам нужны.

Подсказка: используйте рекурсию.
```c++
#include <iostream>

void stack(int);

int main()
{
  int num;
  std::cin >> num;
  stack(num);
  return 0;
}

void stack(int num)
{
  if (num != 0)
  {
    int next;
    std::cin >> next;
    stack(next);
    std::cout << num << " ";
  }
}
```

---

В этой задаче вам нужно реализовать функцию, которая сдвигает содержимое массива влево на заданное число позиций (циклический сдвиг).

На вход функция принимает массив, его размер и величину сдвига. Например, если на вход функции подан массив: int a[] = { 1, 2, 3, 4, 5 }; и требуется циклически сдвинуть его влево на 2 позиции, то на выходе мы получим числа в таком порядке: 3, 4, 5, 1, 2.

Обратите внимание, что величина сдвига может быть нулевой, а может быть и больше размера массива, все эти случаи нужно учесть.

Требования к реализации: вам нужно реализовать только функцию циклического сдвига. При этом она не должна вводить или выводить что-либо. При решении этой задачи вы можете определять любые вспомогательные функции, если они вам нужны. Реализовывать функцию main не нужно. Предполагается, что вам не потребуется дополнительная память, а именно: массивы и стандартные контейнеры. Пользоваться стандартными алгоритмами и контейнерами не разрешается, даже если вы с ними знакомы.

Рекомендация: перед тем, как начать кодировать решение этой задачи, продумайте алгоритм, который вы будете использовать. В данной задаче не проверяется эффективность этого алгоритма (в разумных пределах).

Подсказка: вам может потребоваться оператор % для вычисления остатка. Наиболее простая реализация этой функции сдвигает массив на один элемент за проход. Наиболее простая реализация несколько раз использует функцию, которая переставляет элементы массива в обратном порядке.
```c++
void rotate(int a[], unsigned size, int shift)
{
  shift %= int(size);

  if (shift)
  {
    //преобразование отрицательного сдвига
    shift = shift > 0 ? shift : size + shift;

    //реверс всего массива
    int *pb = a;
    int *pe = a + size - 1;
    while (pb < pe)
    {
      int t = *pb;
      *pb++ = *pe;
      *pe-- = t;
    }

    //реверс 1 блока
    pb = a;
    pe = a + size - 1 - shift;
    while (pb < pe)
    {
      int t = *pb;
      *pb++ = *pe;
      *pe-- = t;
    }

    //реверс 2 блока
    pb = a + size - shift;
    pe = a + size - 1;
    while (pb < pe)
    {
      int t = *pb;
      *pb++ = *pe;
      *pe-- = t;
    }
  }
}
```

---

Очень часто для работы со строками нам нужно сначала вычислить длину строки. Для C-style строк длина нигде явно не хранится, но её можно вычислить. Напишите функцию, которая вычисляет длину C-style строки. Учтите, что завершающий нулевой символ считать не нужно.

Требования к реализации: при выполнении этого задания вы можете создавать любые вспомогательные функции. Вводить или выводить что-либо не нужно. Реализовывать функцию main не нужно.
```c++
unsigned strlen(const char *str)
{
    unsigned int n = 0;
    int i = 0;
    while (str[i] != '\0') {
        i++;
        n++;
    }
    return n;
}
```

---

Вам требуется реализовать функцию конкатенации (склейки) двух C-style строк. Функция конкатенации принимает на вход две C-style строки и дописывает вторую в конец первой так, чтобы первая строка представляла из себя одну C-style строку равную конкатенации двух исходных.

Не забудьте, что в результирующей строке должен быть только один нулевой символ — тот, что является маркером конца строки.

Гарантируется, что в первой строке достаточно памяти (т.е. она располагается в массиве достаточной длины), чтобы разместить конкатенацию обеих строк, но не больше.

Требования к реализации: при выполнении задания вы можете определять любые вспомогательные функции, если они вам нужны. Выводить или вводить что-либо не нужно. Функцию main определять не нужно.
```c++
void strcat(char *to, const char *from)
{
  for (; *to; to++);
  for (; *from != '\0';)
  {
    *to++ = *from++;
  }
  *to++ = '\0';
}
```

---

Напишите функцию поиска первого вхождения шаблона в текст. В качестве первого параметра функция принимает текст (C-style строка), в которой нужно искать шаблон. В качестве второго параметра строку-шаблон (C-style строка), которую нужно найти. Функция возвращает позицию первого вхождения строки-шаблона, если он присутствует в строке (помните, что в C++ принято считать с 0), и -1, если шаблона в тексте нет.

Учтите, что пустой шаблон (строка длины 0) можно найти в любом месте текста.

Требования к реализации: при выполнении данного задания вы можете определять любые вспомогательные функции, если они вам нужны. Вводить или выводить что-либо не нужно. Реализовывать функцию main не нужно.

### No solution

---

В этой задаче вам нужно реализовать функцию resize. Функция resize принимает на вход три аргумента: указатель на область памяти, выделенную с помощью оператора new[], размер области (size) и новый размер (new_size). Функция должна выделить память размера new_size, скопировать в нее данные из переданной области памяти, освободить старую область памяти и вернуть выделенную область памяти нового размера со скопированными данными.  

Обратите внимание, что память, возвращенная из функции, будет освобождена с помощью оператора delete[]. Несмотря на то, что входной тип данных — это const char *, не стоит рассчитывать, что там хранится C-style строка. При выполнении задания также учтите, что new_size может быть меньше size.

Требования к реализации: при выполнении данного задания вы можете определять любые вспомогательные функции. Вводить или выводить что-либо не нужно. Определять функцию main не нужно.
```c++
char *resize(const char *str, unsigned size, unsigned new_size)
{
  char *new_str = new char[new_size];
  for (int i = 0; i < size && i < new_size; ++i)
  {
    new_str[i] = str[i];
  }
  delete[] str;

  return new_str;
}
```

---

Реализуйте функцию getline, которая считывает поток ввода посимвольно, пока не достигнет конца потока или не встретит символ переноса строки ('\n'), и возвращает C-style строку с прочитанными символами.

Обратите внимание, что так как размер ввода заранее неизвестен, то вам нужно будет перевыделять память в процессе чтения, если в потоке ввода оказалось больше символов, чем вы ожидали.

Память, возвращенная из функции будет освобождена оператором delete[]. Символ переноса строки ('\n') добавлять в строку не нужно, но не забудьте, что в конце C-style строки должен быть завершающий нулевой символ.

Требования к реализации: при выполнении данного задания вы можете определять любые вспомогательные функции, если они вам нужны. Определять функцию main не нужно.
```c++
char *getline()
{
  const int BUF_LEN = 50;

  int len = BUF_LEN;
  int i = 0;

  char *str = (char *) malloc(BUF_LEN * sizeof(char)), c;
  while (std::cin.get(c) && c != '\n')
  {
    if (i == len)
      str = (char *) realloc(str, len += BUF_LEN);
    str[i++] = c;
  }

  char *rez = new char[i + 1];
  for (int j = 0; j < i; ++j)
    rez[j] = str[j];
  rez[i] = 0;

  free(str);
  return rez;
}
```

---

Напишите функцию, которая принимает на вход целочисленную матрицу M (другими словами, просто двумерный целочисленный массив) размера rows×cols, и возвращает транспонированную матрицу MT (тоже двумерный целочисленный массив) размера cols×rows. Если в M на пересечении i-ой строки и j-ого столбца стояло число x, то на пересечении  j-ой строки и i-ого столбца в матрице MT тоже будет стоять число x, или другими словами MT[j][i]=M[i][j].

Обратите внимание, что вам неизвестно, каким именно способом выделялась память для массива M. Выделять память под массив MT можете любым удобным вам способом. Изменять исходную матрицу нельзя.

Требования к реализации: при выполнении этого задания вы можете определять любые вспомогательные функции. Вводить или выводить что-либо не нужно. Реализовывать функцию main не нужно.
```c++
int **transpose(const int *const *m, unsigned rows, unsigned cols)
{
  int **matrix = new int *[cols];
  matrix[0] = new int[rows * cols];
  for (int i = 1; i < cols; ++i)
  {
    matrix[i] = matrix[i - 1] + rows;
  }

  for (int i = 0; i < rows; ++i)
  {
    for (int j = 0; j < cols; ++j)
    {
      matrix[j][i] = m[i][j];
    }
  }
  return matrix;
}
```

---

Реализуйте функцию swap_min, которая принимает на вход двумерный массив целых чисел, ищет в этом массиве строку, содержащую наименьшее среди всех элементов массива значение, и меняет эту строку местами с первой строкой массива.

Подумайте, как обменять строки массива, не обменивая элементы строк по-отдельности.

Требования к реализации: при выполнении этого задания вы можете определять любые вспомогательные функции. Вводить или выводить что-либо не нужно. Реализовывать функцию main не нужно.
```c++
void swap_min(int *m[], unsigned rows, unsigned cols)
{
  int minNumber = 0;
  int min = m[0][0];
  for (int i = 0; i < rows; ++i)
  {
    for (int j = 0; j < cols; ++j)
    {
      if (min > m[i][j]){
        minNumber = i;
        min = m[i][j];
      }
    }
  }

  int *temp = m[minNumber];
  m[minNumber] = m[0];
  m[0] = temp;
}
```

---
```c++
#include <cstddef> // size_t
#include <cstring> // strlen, strcpy

struct String {

	String(const char *str = "") {
        this->size = (strlen(str));
        this->str = (new char[strlen(str)+1]);
        strcpy(this->str, str);
    }
    
	size_t size;
	char *str;
};
```

---
