# Stepik_course_c++
https://stepik.org/course/7/syllabus


Напишите функцию power, реализующую возведение целого числа в неотрицательную целую степень. Функция power должна принимать на вход два целых числа и возвращать целое число (смотрите шаблон кода). При выполнении задания учтите, что функция обязательно должна называться power, функция ничего не должна читать со входа или выводить.
Требования к реализации: в этом задании вам нужно реализовать только функцию power. Вы можете определять вспомогательные функции, если они вам нужны. Реализовывать функции main не нужно. 
Ограничения: библиотеку cmath (и math.h) использовать запрещено.
```c++
int power(int x, unsigned p) {
  int answer = 1;
  for (int i = 0; i < p; ++i) {
    answer *= x;
  }
  return answer;
}
```

---

Из лекции вы узнали, что использование макросов вместо функций — это зло. Для того, чтобы лучше разобраться, почему так непросто написать хороший макрос, и почему макросы лучше не использовать, мы предлагаем вам самостоятельно реализовать такую функцию-макрос.
Реализуйте макрос MAX от трёх параметров, который присваивает целочисленной (int) переменной, переданной в качестве третьего аргумента, наибольшее из значений, переданных в первых двух аргументах. Пример вызова макроса:
```c++
int a = 10;
int b = 20;
int c = 0;
MAX(a, b, c); // теперь c равно 20
MAX(a += b, b, c); // теперь a = с = 30
```
При написании макроса постарайтесь учесть как можно больше вариантов его использования. 

Требования к реализации: вам нужно реализовать только макрос MAX. Функцию main и какие-либо другие функции реализовывать не нужно. Попробуйте решить эту задачу исключительно средствами макросов.

Подсказка: возможно вам потребуется какая-нибудь синтаксическая конструкция для объединения нескольких инструкций.  Помните, что макросы просто подставляют текст в место вызова, препроцессор ничего не знает про синтаксис C++. Напишите макрос так, чтобы при его подстановке в месте вызова получился корректный код. Проверьте, что Ваш код можно применить несколько раз в одной функции и это не вызовет ошибку. Если будете определять какие-нибудь переменные, то постарайтесь сделать так, чтобы они не влияли на внешний код.

```c++
#define MAX(x, y, r) \
do { int aa = ( x ); int bb = ( y ); ( r ) = bb < aa ? aa : bb; } while ( false )
```

---

Простая задача на закрепления материала по работе с  вводом/выводом. Напишите программу, которая суммирует целые числа. На вход программе подаются целые числа в следующем формате: на первой строке идет целое число T — количество тестов, далее следует T строк, в каждой из которых через пробел идут два целых числа ai и bi. На выводе для каждой из T строк нужно вывести сумму ai+bi  в том порядке, в котором пары поступают на вход. Ничего, кроме этого, выводить не нужно.
```c++
#include <iostream>
using namespace std;

int main()
{
  int T;
  cin >> T;
  int a, b;
  for (int i = 0; i < T; ++i)
  {
    cin >> a;
    cin >> b;
    cout << a + b << '\n';
  }
  return 0;
}
```

---

Напишите программу для решения квадратных уравнений вида ax2+bx+c=0 (относительно x). На вход программа получает три целых числа: a , b и c, соответственно. При этом гарантируется, что a≠0. На вывод программа должна вывести два вещественных корня уравнения, разделённые пробелом. Если вещественных корней нет, то программа должна вывести строку "No real roots". Если у уравнения имеется только один корень (кратный корень), то программа должна вывести его дважды. Порядок вывода корней не важен. Ничего, кроме этого, выводить не нужно. Для вычислений с плавающей точкой используйте тип double. При выполнении задания вам может оказаться полезной функция sqrt из заголовочного файла cmath.

Замечание: после того, как вы сдадите это задание, попробуйте подумать, как изменилась бы ваша программа, если бы мы не гарантировали, что a≠0.
```c++
#include <iostream>
#include <cmath>

int main()
{
  int a, b, c;

  std::cin >> a >> b >> c;
  int discriminant = b * b - 4 * a * c;
  if (discriminant >= 0)
  {
    double r1 = (-b + sqrt(discriminant)) / (2 * a);
    double r2 = (-b - sqrt(discriminant)) / (2 * a);
    std::cout << r1 << " " << r2;
  }
  else
  {
    std::cout << "No real roots";
  }

  return 0;
}
```

---

Напишите программу, которая посимвольно читает из std::cin, пока не достигнет конца потока ввода, и заменяет несколько подряд идущих пробелов одним и выводит полученный результат в std::cout. Никаких других символов, кроме пробелов удалять не нужно. При выполнении задания вам не разрешается пользоваться дополнительной памятью, а именно: массивами, стандартными контейнерами и строками, даже если вы уже с ними знакомы. Вы можете определять любые вспомогательные функции, если они вам нужны.

Подсказка: прочтите внимательно степ про посимвольный ввод. Нулевой символ ('\0'), символ новой строки ('\n') и конец потока — это три разные вещи. Про то, как отловить конец потока —  написано в степе про посимвольный ввод.
```c++
#include <iostream>

using namespace std;

int main()
{
  char c = '\0';
  while (cin.get(c))
  {
    while (c == ' ' && cin.peek() == ' ')
    {
      cin.get(c);
    }
    cout << c;
  }
  return 0;
};
```

---

Напишите программу для вычисления целочисленного логарифма по основанию 2. На вход программе в первой строке подается число T, далее следует T строк с тестами. Каждый тест состоит из одного целого положительного числа ai<109, для каждого ai нужно вывести на отдельной строке такое наибольшее число p, что 2p≤ai. Гарантируется, что ai≥1 . При решении задачи вы можете определять любые вспомогательные функции, если они вам нужны, более того рекомендуется вынести вычисление логарифма в отдельную функцию.

Ограничения: библиотеку cmath (и math.h) использовать запрещено.
```c++
#include <iostream>

int log(int);

int main()
{
  int n;
  std::cin >> n;
  while (n--)
  {
    int k;
    std::cin >> k;

    std::cout << log(k) << std::endl;
  }
  return 0;
}

int log(int k)
{
  int p = -1;
  do
  {
    k >>= 1;
    ++p;
  } while (k);

  return p;
}
```

---

Напишите рекурсивную функцию вычисления наибольшего общего делителя двух положительных целых чисел (Greatest Common Divisor, GCD). Для этого воспользуйтесь следующими свойствами:

1. GCD(a,b)=GCD(b,amodb) 
2. GCD(0,a)=a 
3. GCD(a,b)=GCD(b,a) 
Требования к реализации: в данном задании запрещено пользоваться циклами. Вы можете заводить любые вспомогательные функции, если они вам нужны. Функцию main определять не нужно.
```c++
unsigned gcd(unsigned a, unsigned b)
{
  return !b ? a : gcd(b, a % b);
}
```

---
