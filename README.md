# Stepik_course_c++
https://stepik.org/course/7/syllabus


Напишите функцию power, реализующую возведение целого числа в неотрицательную целую степень. Функция power должна принимать на вход два целых числа и возвращать целое число (смотрите шаблон кода). При выполнении задания учтите, что функция обязательно должна называться power, функция ничего не должна читать со входа или выводить.
Требования к реализации: в этом задании вам нужно реализовать только функцию power. Вы можете определять вспомогательные функции, если они вам нужны. Реализовывать функции main не нужно. 
Ограничения: библиотеку cmath (и math.h) использовать запрещено.
```c++
int power(int x, unsigned p) {
  int answer = 1;
  for (int i = 0; i < p; ++i) {
    answer *= x;
  }
  return answer;
}
```

---

Из лекции вы узнали, что использование макросов вместо функций — это зло. Для того, чтобы лучше разобраться, почему так непросто написать хороший макрос, и почему макросы лучше не использовать, мы предлагаем вам самостоятельно реализовать такую функцию-макрос.
Реализуйте макрос MAX от трёх параметров, который присваивает целочисленной (int) переменной, переданной в качестве третьего аргумента, наибольшее из значений, переданных в первых двух аргументах. Пример вызова макроса:
```c++
int a = 10;
int b = 20;
int c = 0;
MAX(a, b, c); // теперь c равно 20
MAX(a += b, b, c); // теперь a = с = 30
```
При написании макроса постарайтесь учесть как можно больше вариантов его использования. 

Требования к реализации: вам нужно реализовать только макрос MAX. Функцию main и какие-либо другие функции реализовывать не нужно. Попробуйте решить эту задачу исключительно средствами макросов.

Подсказка: возможно вам потребуется какая-нибудь синтаксическая конструкция для объединения нескольких инструкций.  Помните, что макросы просто подставляют текст в место вызова, препроцессор ничего не знает про синтаксис C++. Напишите макрос так, чтобы при его подстановке в месте вызова получился корректный код. Проверьте, что Ваш код можно применить несколько раз в одной функции и это не вызовет ошибку. Если будете определять какие-нибудь переменные, то постарайтесь сделать так, чтобы они не влияли на внешний код.

```c++
#define MAX(x, y, r) \
do { int aa = ( x ); int bb = ( y ); ( r ) = bb < aa ? aa : bb; } while ( false )
```

---

Простая задача на закрепления материала по работе с  вводом/выводом. Напишите программу, которая суммирует целые числа. На вход программе подаются целые числа в следующем формате: на первой строке идет целое число T — количество тестов, далее следует T строк, в каждой из которых через пробел идут два целых числа ai и bi. На выводе для каждой из T строк нужно вывести сумму ai+bi  в том порядке, в котором пары поступают на вход. Ничего, кроме этого, выводить не нужно.
```c++
#include <iostream>
using namespace std;

int main()
{
  int T;
  cin >> T;
  int a, b;
  for (int i = 0; i < T; ++i)
  {
    cin >> a;
    cin >> b;
    cout << a + b << '\n';
  }
  return 0;
}
```

---

Напишите программу для решения квадратных уравнений вида ax2+bx+c=0 (относительно x). На вход программа получает три целых числа: a , b и c, соответственно. При этом гарантируется, что a≠0. На вывод программа должна вывести два вещественных корня уравнения, разделённые пробелом. Если вещественных корней нет, то программа должна вывести строку "No real roots". Если у уравнения имеется только один корень (кратный корень), то программа должна вывести его дважды. Порядок вывода корней не важен. Ничего, кроме этого, выводить не нужно. Для вычислений с плавающей точкой используйте тип double. При выполнении задания вам может оказаться полезной функция sqrt из заголовочного файла cmath.

Замечание: после того, как вы сдадите это задание, попробуйте подумать, как изменилась бы ваша программа, если бы мы не гарантировали, что a≠0.
```c++
#include <iostream>
#include <cmath>

int main()
{
  int a, b, c;

  std::cin >> a >> b >> c;
  int discriminant = b * b - 4 * a * c;
  if (discriminant >= 0)
  {
    double r1 = (-b + sqrt(discriminant)) / (2 * a);
    double r2 = (-b - sqrt(discriminant)) / (2 * a);
    std::cout << r1 << " " << r2;
  }
  else
  {
    std::cout << "No real roots";
  }

  return 0;
}
```

---

Напишите программу, которая посимвольно читает из std::cin, пока не достигнет конца потока ввода, и заменяет несколько подряд идущих пробелов одним и выводит полученный результат в std::cout. Никаких других символов, кроме пробелов удалять не нужно. При выполнении задания вам не разрешается пользоваться дополнительной памятью, а именно: массивами, стандартными контейнерами и строками, даже если вы уже с ними знакомы. Вы можете определять любые вспомогательные функции, если они вам нужны.

Подсказка: прочтите внимательно степ про посимвольный ввод. Нулевой символ ('\0'), символ новой строки ('\n') и конец потока — это три разные вещи. Про то, как отловить конец потока —  написано в степе про посимвольный ввод.
```c++
#include <iostream>

using namespace std;

int main()
{
  char c = '\0';
  while (cin.get(c))
  {
    while (c == ' ' && cin.peek() == ' ')
    {
      cin.get(c);
    }
    cout << c;
  }
  return 0;
};
```

---

Напишите программу для вычисления целочисленного логарифма по основанию 2. На вход программе в первой строке подается число T, далее следует T строк с тестами. Каждый тест состоит из одного целого положительного числа ai<109, для каждого ai нужно вывести на отдельной строке такое наибольшее число p, что 2p≤ai. Гарантируется, что ai≥1 . При решении задачи вы можете определять любые вспомогательные функции, если они вам нужны, более того рекомендуется вынести вычисление логарифма в отдельную функцию.

Ограничения: библиотеку cmath (и math.h) использовать запрещено.
```c++
#include <iostream>

int log(int);

int main()
{
  int n;
  std::cin >> n;
  while (n--)
  {
    int k;
    std::cin >> k;

    std::cout << log(k) << std::endl;
  }
  return 0;
}

int log(int k)
{
  int p = -1;
  do
  {
    k >>= 1;
    ++p;
  } while (k);

  return p;
}
```

---

Напишите рекурсивную функцию вычисления наибольшего общего делителя двух положительных целых чисел (Greatest Common Divisor, GCD). Для этого воспользуйтесь следующими свойствами:

1. GCD(a,b)=GCD(b,amodb) 
2. GCD(0,a)=a 
3. GCD(a,b)=GCD(b,a) 
Требования к реализации: в данном задании запрещено пользоваться циклами. Вы можете заводить любые вспомогательные функции, если они вам нужны. Функцию main определять не нужно.
```c++
unsigned gcd(unsigned a, unsigned b)
{
  return !b ? a : gcd(b, a % b);
}
```

---

Вам требуется написать программу, которая "переворачивает" последовательность положительных целых чисел. На вход подается последовательность разделенных пробелами положительных целых чисел. Последовательность заканчивается нулем. Требуется вывести эту последовательность в обратном порядке.

На выводе числа нужно так же разделить пробелами. Завершающий ноль — это просто индикатор конца последовательности, он не является ее частью, т.е. выводить его не нужно.

Требования к реализации: в данном задании запрещено использовать циклы, а также дополнительную память: массивы, строки или контейнеры (даже, если вы с ними уже знакомы). Вам разрешено заводить вспомогательные функции, если они вам нужны.

Подсказка: используйте рекурсию.
```c++
#include <iostream>

void stack(int);

int main()
{
  int num;
  std::cin >> num;
  stack(num);
  return 0;
}

void stack(int num)
{
  if (num != 0)
  {
    int next;
    std::cin >> next;
    stack(next);
    std::cout << num << " ";
  }
}
```

---

В этой задаче вам нужно реализовать функцию, которая сдвигает содержимое массива влево на заданное число позиций (циклический сдвиг).

На вход функция принимает массив, его размер и величину сдвига. Например, если на вход функции подан массив: int a[] = { 1, 2, 3, 4, 5 }; и требуется циклически сдвинуть его влево на 2 позиции, то на выходе мы получим числа в таком порядке: 3, 4, 5, 1, 2.

Обратите внимание, что величина сдвига может быть нулевой, а может быть и больше размера массива, все эти случаи нужно учесть.

Требования к реализации: вам нужно реализовать только функцию циклического сдвига. При этом она не должна вводить или выводить что-либо. При решении этой задачи вы можете определять любые вспомогательные функции, если они вам нужны. Реализовывать функцию main не нужно. Предполагается, что вам не потребуется дополнительная память, а именно: массивы и стандартные контейнеры. Пользоваться стандартными алгоритмами и контейнерами не разрешается, даже если вы с ними знакомы.

Рекомендация: перед тем, как начать кодировать решение этой задачи, продумайте алгоритм, который вы будете использовать. В данной задаче не проверяется эффективность этого алгоритма (в разумных пределах).

Подсказка: вам может потребоваться оператор % для вычисления остатка. Наиболее простая реализация этой функции сдвигает массив на один элемент за проход. Наиболее простая реализация несколько раз использует функцию, которая переставляет элементы массива в обратном порядке.
```c++
void rotate(int a[], unsigned size, int shift)
{
  shift %= int(size);

  if (shift)
  {
    //преобразование отрицательного сдвига
    shift = shift > 0 ? shift : size + shift;

    //реверс всего массива
    int *pb = a;
    int *pe = a + size - 1;
    while (pb < pe)
    {
      int t = *pb;
      *pb++ = *pe;
      *pe-- = t;
    }

    //реверс 1 блока
    pb = a;
    pe = a + size - 1 - shift;
    while (pb < pe)
    {
      int t = *pb;
      *pb++ = *pe;
      *pe-- = t;
    }

    //реверс 2 блока
    pb = a + size - shift;
    pe = a + size - 1;
    while (pb < pe)
    {
      int t = *pb;
      *pb++ = *pe;
      *pe-- = t;
    }
  }
}
```

---

Очень часто для работы со строками нам нужно сначала вычислить длину строки. Для C-style строк длина нигде явно не хранится, но её можно вычислить. Напишите функцию, которая вычисляет длину C-style строки. Учтите, что завершающий нулевой символ считать не нужно.

Требования к реализации: при выполнении этого задания вы можете создавать любые вспомогательные функции. Вводить или выводить что-либо не нужно. Реализовывать функцию main не нужно.
```c++
unsigned strlen(const char *str)
{
    unsigned int n = 0;
    int i = 0;
    while (str[i] != '\0') {
        i++;
        n++;
    }
    return n;
}
```

---

Вам требуется реализовать функцию конкатенации (склейки) двух C-style строк. Функция конкатенации принимает на вход две C-style строки и дописывает вторую в конец первой так, чтобы первая строка представляла из себя одну C-style строку равную конкатенации двух исходных.

Не забудьте, что в результирующей строке должен быть только один нулевой символ — тот, что является маркером конца строки.

Гарантируется, что в первой строке достаточно памяти (т.е. она располагается в массиве достаточной длины), чтобы разместить конкатенацию обеих строк, но не больше.

Требования к реализации: при выполнении задания вы можете определять любые вспомогательные функции, если они вам нужны. Выводить или вводить что-либо не нужно. Функцию main определять не нужно.
```c++
void strcat(char *to, const char *from)
{
  for (; *to; to++);
  for (; *from != '\0';)
  {
    *to++ = *from++;
  }
  *to++ = '\0';
}
```

---

Напишите функцию поиска первого вхождения шаблона в текст. В качестве первого параметра функция принимает текст (C-style строка), в которой нужно искать шаблон. В качестве второго параметра строку-шаблон (C-style строка), которую нужно найти. Функция возвращает позицию первого вхождения строки-шаблона, если он присутствует в строке (помните, что в C++ принято считать с 0), и -1, если шаблона в тексте нет.

Учтите, что пустой шаблон (строка длины 0) можно найти в любом месте текста.

Требования к реализации: при выполнении данного задания вы можете определять любые вспомогательные функции, если они вам нужны. Вводить или выводить что-либо не нужно. Реализовывать функцию main не нужно.

### No solution

---

В этой задаче вам нужно реализовать функцию resize. Функция resize принимает на вход три аргумента: указатель на область памяти, выделенную с помощью оператора new[], размер области (size) и новый размер (new_size). Функция должна выделить память размера new_size, скопировать в нее данные из переданной области памяти, освободить старую область памяти и вернуть выделенную область памяти нового размера со скопированными данными.  

Обратите внимание, что память, возвращенная из функции, будет освобождена с помощью оператора delete[]. Несмотря на то, что входной тип данных — это const char *, НЕ стоит рассчитывать, что там хранится C-style строка. При выполнении задания также учтите, что new_size может быть меньше size.

Требования к реализации: при выполнении данного задания вы можете определять любые вспомогательные функции. Вводить или выводить что-либо не нужно. Определять функцию main не нужно.
```c++
char *resize(const char *str, unsigned size, unsigned new_size)
{
  char *new_str = new char[new_size];
  for (int i = 0; i < size && i < new_size; ++i)
  {
    new_str[i] = str[i];
  }
  delete[] str;

  return new_str;
}
```

---

Реализуйте функцию getline, которая считывает поток ввода посимвольно, пока не достигнет конца потока или не встретит символ переноса строки ('\n'), и возвращает C-style строку с прочитанными символами.

Обратите внимание, что так как размер ввода заранее неизвестен, то вам нужно будет перевыделять память в процессе чтения, если в потоке ввода оказалось больше символов, чем вы ожидали.

Память, возвращенная из функции будет освобождена оператором delete[]. Символ переноса строки ('\n') добавлять в строку не нужно, но не забудьте, что в конце C-style строки должен быть завершающий нулевой символ.

Требования к реализации: при выполнении данного задания вы можете определять любые вспомогательные функции, если они вам нужны. Определять функцию main не нужно.
```c++
char *getline()
{
  const int BUF_LEN = 50;

  int len = BUF_LEN;
  int i = 0;

  char *str = (char *) malloc(BUF_LEN * sizeof(char)), c;
  while (std::cin.get(c) && c != '\n')
  {
    if (i == len)
      str = (char *) realloc(str, len += BUF_LEN);
    str[i++] = c;
  }

  char *rez = new char[i + 1];
  for (int j = 0; j < i; ++j)
    rez[j] = str[j];
  rez[i] = 0;

  free(str);
  return rez;
}
```

---

Напишите функцию, которая принимает на вход целочисленную матрицу M (другими словами, просто двумерный целочисленный массив) размера rows×cols, и возвращает транспонированную матрицу MT (тоже двумерный целочисленный массив) размера cols×rows. Если в M на пересечении i-ой строки и j-ого столбца стояло число x, то на пересечении  j-ой строки и i-ого столбца в матрице MT тоже будет стоять число x, или другими словами MT[j][i]=M[i][j].

Обратите внимание, что вам неизвестно, каким именно способом выделялась память для массива M. Выделять память под массив MT можете любым удобным вам способом. Изменять исходную матрицу нельзя.

Требования к реализации: при выполнении этого задания вы можете определять любые вспомогательные функции. Вводить или выводить что-либо не нужно. Реализовывать функцию main не нужно.
```c++
int **transpose(const int *const *m, unsigned rows, unsigned cols)
{
  int **matrix = new int *[cols];
  matrix[0] = new int[rows * cols];
  for (int i = 1; i < cols; ++i)
  {
    matrix[i] = matrix[i - 1] + rows;
  }

  for (int i = 0; i < rows; ++i)
  {
    for (int j = 0; j < cols; ++j)
    {
      matrix[j][i] = m[i][j];
    }
  }
  return matrix;
}
```

---

Реализуйте функцию swap_min, которая принимает на вход двумерный массив целых чисел, ищет в этом массиве строку, содержащую наименьшее среди всех элементов массива значение, и меняет эту строку местами с первой строкой массива.

Подумайте, как обменять строки массива, не обменивая элементы строк по-отдельности.

Требования к реализации: при выполнении этого задания вы можете определять любые вспомогательные функции. Вводить или выводить что-либо не нужно. Реализовывать функцию main не нужно.
```c++
void swap_min(int *m[], unsigned rows, unsigned cols)
{
  int minNumber = 0;
  int min = m[0][0];
  for (int i = 0; i < rows; ++i)
  {
    for (int j = 0; j < cols; ++j)
    {
      if (min > m[i][j]){
        minNumber = i;
        min = m[i][j];
      }
    }
  }

  int *temp = m[minNumber];
  m[minNumber] = m[0];
  m[0] = temp;
}
```

---
```c++
#include <cstddef> // size_t
#include <cstring> // strlen, strcpy

struct String {

	String(const char *str = "") {
        this->size = (strlen(str));
        this->str = (new char[strlen(str)+1]);
        strcpy(this->str, str);
    }
    
	size_t size;
	char *str;
};
```

---

Конструкторов у структуры может быть несколько. Для строки может оказаться полезным заполняющий конструктор (например, чтобы создать строку пробелов). Заполняющий конструктор принимает число и символ, и создает строку с заданным количеством повторений переданного символа. Условия налагаемые на реализацию конструктора те же самые (в поле size размер без учета завершающего 0 символа, в поле str C-style строка, т.е. с завершающим 0 символом). Кроме конструктора в этой задаче вам нужно также реализовать и деструктор, который освободит выделенную память.
Требования к решению: в этом задании не нужно вводить или выводить что-либо, не нужно реализовывать функцию main. Для работы с памятью не используйте функции из cstdlib (malloc, calloc, realloc и free).
```c++
#include <cstddef> // size_t
#include <cstring> // strlen, strcpy

struct String {

    /* Реализуйте этот конструктор */
    String(size_t n, char c) {
        this->size = n;
        this->str = new char[n+1];
        for (size_t i = 0; i != n; ++i) {
            this->str[i] = c;
        }
        this->str[n+1] = '\0';
        
    }

    /* и деструктор */
    ~String() {
        delete [] str;
    }


	size_t size;
	char *str;
};
```

---

Реализованные в предыдущих заданиях конструкторы и деструктор берут на себя работу по управлению ресурсами. Теперь можно дополнить структуру String различными полезными методами.

Для работы со строками можно придумать множество полезных методов (подумайте, какие методы пригодились бы вам, и чего вам не хватает для их реализации). Примером такого метода может послужить метод append — он добавляет копию строки-аргумента в конец текущей строки (т.е. в конец строки, у которой он был вызван). 
```c++
String s1("Hello,");
String s2(" world!");
s1.append(s2); // теперь s1 хранит "Hello, world!"
```
Ваша задача реализовать метод append.

При выполнении задания будьте аккуратны при работе с памятью — при вызове метода не должно возникать утечек памяти. Кроме того, не забудьте, что size хранит размер без учета завершающего 0 символа. 

Требования к реализации: при реализации вы можете заводить любые вспомогательные функции и методы. В шаблоне вы увидите объявления уже известных вам конструкторов и деструкторов, реализовывать их заново не нужно, они уже реализованы. Вводить или выводить что-либо не нужно. Реализовывать main не нужно. Для работы с памятью не используйте функции из cstdlib (malloc, realloc, calloc и free).

Кроме того, ваша реализация должна корректно работать в следующем тесте:
```c++
String s("Hello");
s.append(s); // теперь s хранит "HelloHello"
```

```c++
#include <cstddef> // size_t
#include <cstring> // strlen, strcpy

struct String
{
  String(const char *str = "");
  String(size_t n, char c);
  ~String();
  
  /* Реализуйте этот метод. */
  void append(String &other)
  {
    char *temp = new char[this->size + other.size + 1];
    strcat(temp, this->str);
    strcat(temp, other.str);
    strcat(temp, "\0");

    delete[] this->str;
    this->str = temp;
    this->size = strlen(this->str);

  }

  size_t size;
  char *str;
};
```

---

Задание повышенной сложности.

Определен следующий класс (он также приведен в комментарии в шаблоне кода):
```c++
struct Cls {
    Cls(char c, double d, int i);
private:
    char c;
    double d;
    int i;
};
```
Как видно, все поля этого класса закрытые, ваша задача реализовать несколько функций, которые дают полный доступ к этим полям (см. шаблон кода), несмотря на то, что они закрытые.

Внимание: предполагаемое решение этого задания существенно опирается на Undefined Behaviour и является исключительно учебным, но полезно для лучшего понимания того, как работают модификаторы доступа. Решение было проверено на различных компиляторах (g++/clang++/icc/msvc), но мы настоятельно не рекомендуем использовать подобные трюки в боевом коде.

Требования к реализации: при решении этого задания вам разрешается заводить любые вспомогательные функции и классы, но не изменять определение класса Cls. Не нужно вводить или выводить что-либо, также не нужно определять функцию main.
```c++
/*
 * Класс Cls определен точно таким образом:
 *
 * struct Cls {
 * Cls(char c, double d, int i);
 * private:
 *     char c;
 *     double d;
 *     int i;
 * };
 *
 */

// Эта функция должна предоставить доступ к полю c объекта cls.
// Обратите внимание, что возвращается ссылка на char, т. е.
// доступ предоставляется на чтение и запись.
char &get_c(Cls &cls) {
    char* ptr;
    ptr = (char*)&cls;
    return *ptr;
}

// Эта функция должна предоставить доступ к полю d объекта cls.
// Обратите внимание, что возвращается ссылка на double, т. е.
// доступ предоставляется на чтение и запись.
double &get_d(Cls &cls) {
    double* ptr;
    ptr = (double*)( (char*)(&cls) ) + 1;
    return *ptr; 
}

// Эта функция должна предоставить доступ к полю i объекта cls.
// Обратите внимание, что возвращается ссылка на int, т. е.
// доступ предоставляется на чтение и запись.
int &get_i(Cls &cls) {
    double* p;
    int* ptr;
    p = (double*)( (char*)(&cls) ) + 1;
    ptr = (int*) (p + 1);
    
    
    return *ptr;
}
```
---

Свяжите следующие классы в иерархию наследования: Character (Персонаж), LongRange (Персонаж дальнего действия), Wizard (Маг), SwordsMan (Мечник), Archer (Лучник).Обратите внимание на методы, объявленные в классах — они приведены в качестве описания интерфейса, которым должны обладать классы. Не изменяйте объявлений методов — они даны как подсказка, просто добавьте наследование в определения классов.
```c++
#include <string> // std::string

struct Character
{
    std::string const & name() const;
    unsigned health() const;
};

struct LongRange : Character
{
    std::string const & name() const;
    unsigned health() const;

    unsigned range() const;
};

struct SwordsMan : Character
{
    std::string const & name() const;
    unsigned health() const;

    unsigned strength() const;    
};

struct Wizard : LongRange
{
    std::string const & name() const;
    unsigned health() const;

    unsigned range() const;

    unsigned mana() const;
};

struct Archer : LongRange
{
    std::string const & name() const;
    unsigned health() const;

    unsigned range() const;

    unsigned accuracy() const;
};
```

---
Вам дан класс Foo:
```c++
struct Foo {
    void say() const { std::cout << "Foo says: " << msg << "\n"; }
protected:
    Foo(const char *msg) : msg(msg) { }
private:
    const char *msg;
};
```
Как видно, создатель класса не хотел чтобы его использовали и "спрятал" конструктор класса. Но вам очень нужен объект этого класса, чтобы передать его в функцию foo_says:
```c++
void foo_says(const Foo& foo) { foo.say(); }
```
В этом задании вам нужно реализовать функцию get_foo (сигнатура которой намерено не приводится в задании полностью, вам нужно подумать и вывести ее самостоятельно) так, чтобы следующий код компилировался и работал:
```c++
foo_says(get_foo(msg));
```
Где msg — произвольная C-style строка.

Требования к реализации: при выполнении задания вам разрешено вводить любые вспомогательные функции и классы. Запрещено изменять определение класса Foo или функции foo_says. Вводить или выводить что-либо не нужно. Реализовывать функцию main не нужно.
```c++
Foo get_foo(const char *msg) {
    struct Foo1 : Foo {
        public:
        Foo1(const char *msg) : Foo(msg) { }
    };
    
    //Объявляем объект наследник, у которого в качестве аргумента msg и его возвращаем.
    Foo1 f = Foo1(msg);
    return f;
}
```
---

Добавьте в класс String реализацию конструктора копирования. Инвариант класса остается тем же (в size хранится размер строки без завершающего 0 символа, str указывает на C-style строку, т. е. с завершающим нулевым символом).

Требования к реализации: вы можете заводить любые вспомогательные методы или функции, но не реализуйте заново методы из предыдущих заданий — они уже реализованы. При реализации не нужно вводить или выводить что-либо. Реализовывать main не нужно. Не используйте функции из cstdlib (malloc, calloc, realloc и free).
```c++
#include <cstddef> // size_t
#include <cstring> // strlen, strcpy

struct String {
	String(const char *str = "");
	String(size_t n, char c);
	~String();


    /* Реализуйте конструктор копирования */
	String(const String &other):
    size(other.size),
    str(new char[size + 1])
    {
        for (size_t i = 0; i < size; ++i)
        {
            str[i] = other.str[i];
        }
        str[size] = '\0';
    }


	void append(const String &other);

	size_t size;
	char *str;
};
```

---
Завершите класс String, добавив к нему оператор присваивания. Будьте аккуратны при работе с памятью. Инвариант класса остается тем же (в size хранится размер строки без завершающего 0 символа, str указывает на C-style строку, т. е. с завершающим нулевым символом).

Требования к реализации: вы можете заводить любые вспомогательные методы или функции, но не реализуйте заново методы из предыдущих заданий — они уже реализованы. При реализации не нужно вводить или выводить что-либо. Реализовывать main не нужно. Не используйте функции из cstdlib (malloc, calloc, realloc и free).
```c++
#include <algorithm> // std::swap
#include <cstddef>   // size_t
#include <cstring>   // strlen, strcpy

struct String {
	String(const char *str = "");
	String(size_t n, char c);
	String(const String &other);
	~String();

    /* Реализуйте оператор присваивания */
	String &operator=(const String &other)
    {
        if(this != &other)
        {
            if (size == other.size)
            {
                for (size_t i = 0; i < size; ++i)
                {
                    str[i] = other.str[i];
                }
            }
            else
            {
                delete [] str;
                str = new char[other.size + 1];
                size = other.size;
                for (size_t i = 0; i < size; ++i)
                {
                    str[i] = other.str[i];
                }
                str[size] = '\0';
            }
        }
        
        return *this;
    }

	void append(const String &other);

	size_t size;
	char *str;
};
```

---

В этом задании вам предлагается разработать иерархию классов Expression для представления арифметических выражений. Конкретнее, вам нужно определить три класса: Expression — базовый класс иерархии, Number — для представления чисел и BinaryOperation — класс описывающий бинарную операцию (+, ­-, * или /).

Класс Number должен хранить значение типа double.

Класс BinaryOperation должен хранить указатель на левый и правый операнды, которые сами являются арифметическими выражениями, а также тип операции (+, ­-, * или /), которую нужно над ними произвести.

Во всех классах должен быть метод evaluate, который возвращает значение типа double — значение соответствующего арифметического выражения, например, значение экземпляра типа Number — это число, которое он хранит, а если у вас есть объект BinaryOperation с операцией +, то нужно вычислить значения левого и правого операнда и вернуть их сумму.

В данном задании вам нужно расставить ключевое слово virtual там, где это необходимо, определить метод evaluate там, где его не хватает, а также реализовать деструкторы, там где они нужны.

При выполнении этого задания учтите, что при уничтожении объекта BinaryOperation он отвечает за уничтожение левого и правого операндов (гарантируется, что они выделены в динамической памяти).

Например, выражению 3 + 4.5 * 5 будет соответствовать следующий код:
```c++
// сначала создаём объекты для подвыражения 4.5 * 5
Expression * sube = new BinaryOperation(new Number(4.5), '*', new Number(5));
// потом используем его в выражении для +
Expression * expr = new BinaryOperation(new Number(3), '+', sube);

// вычисляем и выводим результат: 25.5
std::cout << expr->evaluate() << std::endl;

// тут освобождаются *все* выделенные объекты
// (например, sube будет правым операндом expr, поэтому его удалять не нужно)
delete expr;
```
Требования к реализации: при выполнении этого задания не нужно вводить или выводить что-либо. Вы можете заводить любые вспомогательные функции, методы или классы, но не нужно реализовывать функцию main.
```c++
struct Expression
{
    virtual ~Expression() {};
    virtual double evaluate() const = 0;
};

struct Number : Expression
{
    Number(double value)
        : value(value)
    {}
    ~Number() {};
    double evaluate() {return value;}
    virtual double evaluate() const {return value;}

private:
    double value;
};

struct BinaryOperation : Expression
{
    /*
      Здесь op это один из 4 символов: '+', '-', '*' или '/', соответствующих операциям,
      которые вам нужно реализовать.
     */
    BinaryOperation(Expression const * left, char op, Expression const * right)
        : left(left), op(op), right(right)
    { }
    
    ~BinaryOperation() {
        delete left;
        delete right;
    }
    
     virtual double evaluate() const {
        
        if (op == '+') {
            return (left->evaluate() + right->evaluate());
        } else if (op == '-') {
            return (left->evaluate() - right->evaluate());
        } else if (op == '*') {
            return (left->evaluate() * right->evaluate());
        } else if (op == '/') {
            return (left->evaluate() / right->evaluate());
        }
    }

private:
    Expression const * left;
    Expression const * right;
    char op;
};
```

---

(Задание повышенной сложности) Предполагаемое решение этого задания не переносимо с точки зрения стандарта, однако оно проверено на различных версиях компиляторов g++/clang++/msvc. Решение этого задания не обязательно для получения диплома по этому курсу, однако мы считаем его полезным, чтобы лучше понять как устроены виртуальные функции внутри.

Вам требуется реализовать функцию, которая принимает на вход два указателя на базовый класс Expression, и возвращает true, если оба указателя указывают на самом деле на объекты одного и того же класса, и false в противном случае (т.е. если оба указателя указывают на BinaryOperation, то возвращается true, а если один из них указывает на Number, а второй на BinaryOperation, то false).

Требования к реализации: пользоваться typeid и dynamic_cast запрещено. Вызывать методы по переданным указателям запрещено.
```c++
bool check_equals(Expression const *left, Expression const *right)
{
    return (*((size_t*)left) == *((size_t*)right));
}
```

---

На прошлом степе вы познакомились с реализацией паттерна посетитель. Теперь пришло время воспользоваться этими знаниями. Ваш класс должен печатать (используя std::cout) текстовое представление арифметического выражения. Т.е. для объекта класса Number он должен напечатать число, которое в нем хранится, а для объекта класса BinaryOperation он должен напечатать левый операнд, затем операцию, а затем правый операнд.

Учтите, что операции + и - имеют меньший приоритет, чем операции * и /, т. е. возможно вам придется печатать дополнительные круглые скобки, чтобы сохранить правильный порядок операций.

Классы иерархии Expression и абстрактный класс Visitor приведены в комментарии в шаблоне для удобства.

При проверке задания лишние пробелы или лишние скобки будут игнорироваться, т.е. вывод "1+2" эквивалентен выводу "( ( 1 )  +   ( 2 ) )", а вот вывод "1 + 2 * 3" не эквивалентен выводу "((1 + 2) * 3)". Вы можете попытаться минимизировать количество скобок в выводе, но это не требуется.

Перед выполнением задания внимательно прочитайте содержимое предыдущего степа.

Требования к реализации: при выполнении задания вы можете заводить любые вспомогательные классы или функции, но не нужно реализовывать функцию main или менять реализацию классов иерархии Expression.


```c++
struct PrintVisitor: Visitor {
 
    void visitNumber(Number const * number) {
        double x = number->evaluate();
        if(x < 0)
            std::cout << "(" << x << ")";
        else
            std::cout << x ;
    }
 
    void visitBinaryOperation(BinaryOperation const * bop) {
        bool is_prev = this->is;  //исходное
        char c = bop->get_op();
        bool is_cur = is_prev && (c == '-' || c == '+'); //снаружи * или /, а у нас + или - => нужны скобки
        if(is_cur)
            std::cout << "(";
        
        
        this->is = c=='*'||c=='/';   //сообщаем внутрь, что у нас приоритетная операция
        bop->get_left()->visit(this);
 
        std::cout << c;
        
        this->is = c=='*'||c =='/'; //сообщаем внутрь, что у нас приоритетная операция
        bop->get_right()->visit(this);
        
        if(is_cur)
            std::cout << ")";
        this->is = is_prev;      //вернем
    }
private:
    bool is=false;
};
```

---

Вам дан класс Rational, который описывает рациональное число. В нем определены методы add, sub, mul и div, которые прибавляют к нему число, отнимают число, умножают на число и делят на число соответственно. Кроме того в нем определен метод neg, который меняет знак на противоположный.

Вам нужно определить операторы +=, -=, *=, /= для класса Rational так, чтобы они могли принимать в качестве аргументов и объекты типа Rational и целые числа. Кроме того вам необходимо определить операторы унарного минуса и плюса для класса Rational.

Требования к реализации: ваш код не должен вводить или вводить что-либо, реализовывать функцию main не нужно. Кроме того, нельзя (это совершенно не нужно) использовать динамическую память или подключать какие-либо библиотеки.
```c++
struct Rational
{
  Rational(int numerator = 0, int denominator = 1);

  void add(Rational rational);
  void sub(Rational rational);
  void mul(Rational rational);
  void div(Rational rational);

  void neg();
  void inv();
  double to_double() const;

  Rational &operator+=(const Rational &rational)
  {
    this->add(rational);
    return *this;
  }

  Rational &operator+=(int d)
  {
    this->add(Rational(d));
    return *this;
  }

  Rational &operator-=(const Rational &rational)
  {
    this->sub(rational);
    return *this;
  }

  Rational &operator-=(int d)
  {
    this->sub(Rational(d));
    return *this;
  }

  Rational &operator*=(const Rational &rational)
  {
    this->mul(rational);
    return *this;
  }

  Rational &operator*=(int d)
  {
    this->mul(Rational(d));
    return *this;
  }

  Rational &operator/=(const Rational &rational)
  {
    this->div(rational);
    return *this;
  }

  Rational &operator/=(int d)
  {
    this->div(Rational(d));
    return *this;
  }

  Rational operator-() const
  {
    Rational r(this->numerator_, this->denominator_);
    r.neg();
    return r;
  }

  Rational operator+() const
  {
    Rational r(this->numerator_, this->denominator_);
    return r;
  }

private:
  int numerator_;
  int denominator_;
};
```

---

Определите для класса Rational операторы сложения, вычитания, умножения и деления, так чтобы объекты типа Rational можно было складывать (вычитать, умножать и делить) не только друг с другом но и с целыми числами.

Требования к реализации: ваш код не должен вводить или выводить что-либо, реализовывать функцию main не нужно.
```c++
struct Rational
{
  Rational(int numerator = 0, int denominator = 1);

  void add(Rational rational);
  void sub(Rational rational);
  void mul(Rational rational);
  void div(Rational rational);

  void neg();
  void inv();
  double to_double() const;

  Rational &operator+=(Rational rational);
  Rational &operator-=(Rational rational);
  Rational &operator*=(Rational rational);
  Rational &operator/=(Rational rational);

  Rational operator-();
  Rational operator+();

private:
  int numerator_;
  unsigned denominator_;
};

Rational operator+(Rational r1, Rational const &r2)
{
  return r1 += r2;
}

Rational operator-(Rational r1, Rational const &r2)
{
  return r1 -= r2;
}

Rational operator*(Rational r1, Rational const &r2)
{
  return r1 *= r2;
}

Rational operator/(Rational r1, Rational const &r2)
{
  return r1 /= r2;
}
```

---

Еще одна важная группа операторов, которые полезно реализовать для класса рациональных чисел — это операторы сравнения. Реализуйте операторы <, <=, >, >=, ==, != для класса Rational так, чтобы можно было сравнивать объекты класса Rational не только друг с другом, но и с целыми числами.

При решении задания не используйте метод to_double, он введен в класс, в первую очередь, для удобства тестирования. Вы можете определять любые вспомогательные методы или функции если необходимо.

Требования к реализации: ваш код не должен вводить или вводить что-либо, реализовывать функцию main не нужно.
```C++
struct Rational
{
    Rational(int numerator = 0, int denominator = 1);
 
    void add(Rational rational);
    void sub(Rational rational);
    void mul(Rational rational);
    void div(Rational rational);
 
    void neg();
    void inv();
    double to_double() const;
 
    Rational& operator+=(Rational rational);
    Rational& operator-=(Rational rational);
    Rational& operator*=(Rational rational);
    Rational& operator/=(Rational rational);
 
    Rational operator-() const;
    Rational operator+() const;
friend bool operator!=(Rational const & lhs, Rational const & rhs);
    friend bool operator==(Rational const & lhs, Rational const & rhs);
    friend bool operator<(Rational const & lhs, Rational const & rhs);
    friend bool operator>(Rational lhs, Rational rhs);
    friend bool operator<=(Rational lhs, Rational rhs);
    friend bool operator>=(Rational lhs, Rational rhs);
    
private:
    int numerator_;
    int denominator_;
};
 
Rational operator+(Rational lhs, Rational rhs);
Rational operator-(Rational lhs, Rational rhs);
Rational operator*(Rational lhs, Rational rhs);
Rational operator/(Rational lhs, Rational rhs);
 
 
 bool operator==(Rational const & lhs, Rational const & rhs){
return (((lhs.numerator_)==(rhs.numerator_)) && ((lhs.denominator_) == (rhs.denominator_)));
}
 bool operator!=(Rational const & lhs, Rational const & rhs){
return !(lhs==rhs);
}
 bool operator<(Rational const & lhs, Rational const & rhs){
return ((int)lhs.numerator_*(int)rhs.denominator_)<((int)rhs.numerator_*(int)lhs.denominator_);
}
 bool operator>(Rational lhs, Rational rhs){
return rhs<lhs;
}
 bool operator<=(Rational lhs, Rational rhs){
return !(lhs>rhs);
}
 bool operator>=(Rational lhs, Rational rhs){
return !(lhs<rhs);
}
```
---

Добавьте в класс Rational оператор приведения к double. Все операторы из предыдущих заданий отсутствуют и реализовывать их не нужно. Метод to_double можно использовать в этом задании.

Важное замечание: добавлять оператор преобразования к double в класс Rational не самая удачная идея, например, потому, что при таком преобразовании может происходить потеря точности. Эта задача дана исключительно с целью ознакомления с правильным порядком перегрузки таких операторов.

Требования к реализации: ваш код не должен вводить или вводить что-либо, реализовывать функцию main не нужно.
```c++
struct Rational
{
    Rational(int numerator = 0, int denominator = 1);
    
    operator double() const{ return to_double(); }
 
    void add(Rational rational);
    void sub(Rational rational);
    void mul(Rational rational);
    void div(Rational rational);
 
    void neg();
    void inv();
    double to_double() const;
 
private:
    int numerator_;
    unsigned denominator_;
};
```

---

Помните иерархию Expression, которую мы разрабатывали на четвёртой неделе? Реализуйте ScopedPtr, который будет работать с указателями на базовый класс Expression. В этом задании вам требуется реализовать методы get, release и reset, операторы * и -> так, как это было описано в предыдущем степе. А также реализуйте конструктор ScopedPtr от указателя на Expression.

Подсказка: в качестве признака того, что ScopedPtr не хранит никакого указателя (после вызова release), используйте нулевой указатель, при этом вы можете явно проверить указатель в деструкторе, но делать это не обязательно, так как delete от нулевого указателя ничего не делает.

Требования к реализации: ваш код не должен вводить или вводить что-либо, реализовывать функцию main не нужно.
```c++
struct Expression;
struct Number;
struct BinaryOperation;
 
struct ScopedPtr {
    // реализуйте следующие методы:
    //
    explicit ScopedPtr(Expression *ptr = 0) {
        this->ptr_=ptr;
    }
    ~ScopedPtr() {
        delete  ptr_;
    }
    Expression* get() const {
        return ptr_;
    }
    Expression* release() {
        Expression * ptr = this->ptr_;
        this->ptr_ = NULL;
        return ptr;
    }
    void reset(Expression *ptr = 0) {
        delete this->ptr_;
        this->ptr_ = ptr;
    }
    Expression& operator*() const {
        return *ptr_;
    }
    Expression* operator->() const {
        return ptr_;
    }
private:
    ScopedPtr& operator=(const ScopedPtr & other) {} //оператор присваивания
    ScopedPtr(const ScopedPtr & other) {} //конструктор копирования
    Expression *ptr_;
};
```

---
Реализуйте класс SharedPtr как описано ранее. Задание немного сложнее, чем кажется на первый взгляд. Уделите особое внимание "граничным случаям" — нулевой указатель, присваивание самому себе, вызов reset на нулевом SharedPtr и прочее.

Подсказка: возможно, вам понадобится завести вспомогательную структуру.

Требования к реализации: ваш код не должен вводить или вводить что-либо, реализовывать функцию main не нужно.
```c++
struct Expression;
struct Number;
struct BinaryOperation;
 
struct Help {
    Help(Expression *ptr=NULL) {
        this->ptr = ptr;
        cnt = 1;
    }
    ~Help() {
        delete ptr;     
    }
    Expression * ptr;
    mutable int cnt ;
};
 
struct SharedPtr {
    // реализуйте следующие методы
    //
    explicit SharedPtr(Expression *ptr = 0) {
        if(ptr != 0)
            h = new Help(ptr);
        else
            h = NULL;
    }
    ~SharedPtr() {      
        if(h!=NULL) {
            --(h->cnt);
            if(h->cnt == 0)
                delete h;
        }
    }
    SharedPtr(const SharedPtr & other) {
        this->h = other.h;
        if(this->h!=NULL && this->h->cnt)
            ++(this->h->cnt);
    }
    SharedPtr& operator=(const SharedPtr & other) {
        if(this!=&other){
            this->~SharedPtr();
            this->h = other.h;
            if(this->h != NULL)
                ++(this->h->cnt);
        }
    }
    Expression* get() const {
        if(this->h != NULL)
            return this->h->ptr;
        else
            return NULL;
    }
    void reset(Expression *ptr = 0) {
        this->~SharedPtr();
        if(ptr != 0)
            h = new Help(ptr);
        else
            h = NULL;
    }
    Expression& operator*() const {
        if(this->h != NULL)
            return *(this->h->ptr);
        else
            return *(Expression *)NULL;
    }
    Expression * operator->() const {
        if(this->h != NULL)
            return this->h->ptr;
        else
            return NULL;
    }
private:
    Help * h=NULL;
};
```

---
